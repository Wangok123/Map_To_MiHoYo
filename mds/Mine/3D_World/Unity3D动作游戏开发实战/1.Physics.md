# 物理系统

## 基本内容

### 基本参数设置

Project Setting中：

- Gravity：重力，默认值为9.81，但在游戏开发中其实是不够用的，建议将该值调大至60～80。
- Queries Hit Backfaces：进行背面射线查询，如果需要查询MeshCollider背面（法线相反的方向）的情况，请开启该功能。
- Layer Collision Matrix：物理相交矩阵，确定多个Layer之间的相交关系，一旦不相交，则不会触发它们之间的碰撞关系。

### Fixed Update

与Update函数每帧更新不同，Fixed Update函数的更新频率是按照时间进行更新的，假如设置为0.01，那么1秒钟必然会执行满100次Fixed Update。

### Rigidbody

- Mass：刚体的质量，不同的质量设置会在游戏里以推力的方式表现出来。例如，大质量的物体会很轻易地推动小质量的物体，但该值并不会影响下落速度。
- Drag：阻尼，不建议保持该值为默认值0。因为游戏中的物理引擎本身就是基于单浮点数的，并不足够精确，过小的阻尼参数会造成结果抖动而出现一些奇怪的Bug。
- Angular Drag：角阻尼，意义与Drag类似但对应于旋转。
- Use Gravity：是否应用重力。
- Is Kinematic：开启此选项后物体不会受到物理特性的影响.
- Interpolate: 插值。内插平滑，外插预测。
- Collision Detection：碰撞检测方式，默认是Discrete关闭连续碰撞检测的状态。对于游戏中的主角或敌人，需要设置成Continuous连续，这样当过快移动时能防止穿墙；对于次重要的物体，比如一些特效生成物，建议设置为ContinuousDynamic或ContinuousSpeculative，以提升性能。
- Constraints: 通过使用 `约束`，可以阻止物体沿某个轴或围绕某个轴旋转，实现特定的物理行为，而不需要额外编写代码来控制这些运动。

Rigidbody 约束分为两大类：

1. Position Constraints（位置约束）：锁定对象在世界空间中的特定轴上的移动。例如：
- Freeze Position X ：物体不能在X轴方向上移动。
- Freeze Position Y ：物体不能在Y轴方向上移动。
- Freeze Position Z ：物体不能在Z轴方向上移动。
2. Rotation Constraints（旋转约束）：锁定对象关于某一轴的旋转。例如：
- Freeze Rotation X ：物体不能绕X轴旋转。
- Freeze Rotation Y ：物体不能绕Y轴旋转。
- Freeze Rotation Z ：物体不能绕Z轴旋转。
- 通过组合使用这些约束，可以创建各种物理行为。例如：

如果你想要一个物体只在平面内移动而不上升或下降，可以约束其在 Y 轴的位置。
对于一个门，你可能想要它仅绕 Y 轴旋转开关，那么就可以约束 X 和 Z 轴的旋转。
在2D游戏中，通常会锁定Z轴的所有移动和旋转，保证游戏物体只在XY平面内移动和旋转。

### 物理材质

[来点官方教程](https://docs.unity3d.com/cn/2019.4/Manual/class-PhysicMaterial.html)

## 常见问题

### 关于物理步

Unity3D中的物理更新时序是按照时间来进行的，在Unity3D的TimeManager中可以设置物理步的更新频率，若更新频率为0.01则表示1秒钟执行100次，这100次会分配到每帧当中，既有可能出现当前帧不执行物理步的情况，也有可能出现当前帧执行2次或者多次物理步的情况。因此，若将输入检测逻辑或需要每帧检测的逻辑放入物理步中进行判断则会出错，开发者需要特别注意这类问题。

### 重叠与挤出问题

当一个刚体对象（A）在另一个碰撞器（B）中时，会发生挤出现象。如果B对象也附着有刚体组件且质量相当，那么它们会有一个相互的斥力；如果B对象没有刚体组件或者刚体组件质量比A对象大很多，那么A对象将会被挤出。如果挤出中的对象碰到了其他非刚体碰撞器或者质量较高带刚体碰撞器，则会停止，卡在原地。

重叠时造成的挤出位移并不是一帧内就执行完成的，而是会分成多步完成，直至不发生重叠为止。由于挤出方向并不能让用户自定义，所以可能会产生朝外挤出的情况，也就是游戏中的穿
墙问题。穿墙通常是由于一些特殊脚本控制的瞬移操作造成的，所以我们首先要保证角色的碰撞检测为连续的，这样可以让刚体驱动的物理位移在高速移动下不会产生穿墙现象。

其次我们可以将一个比较大的场景碰撞拆分成多份，并将一些MeshCollider碰撞勾选Convex转换为凸包，以保证碰撞检测的结果正确性。

<font color = red> 其次我们可以将一个比较大的场景碰撞拆分成多份，并将一
些MeshCollider碰撞勾选Convex转换为凸包，以保证碰撞检测的
结果正确性。(并不懂这里在说什么)

### 地面检测的优化处理

对于地面的检测，若项目中采用Unity3D自带的角色控制器（CharacterController）组件可以通过isGrounded字段进行判断，但不够灵活。

而对于未采用角色控制器的项目，我们可以在角色脚底投射一根射线去检测并保证每帧的执行。但对于较复杂的地面碰撞，一根射线并不能达到准确检测的目的。在Unity3D的Standard Assets Demo中角色用了向下投射胶囊的方式去检测地面，这里参考其做法使用多根射线投射的方式进行检测。

我们可以在编辑器下生成地面检测点，一般使用3个检测点即可。
