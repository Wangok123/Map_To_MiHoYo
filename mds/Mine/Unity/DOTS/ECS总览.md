# 实体

一个实体代表了程序中具有独立数据集的离散对象，如角色、视觉效果、UI元素，甚至是像网络事务这样的抽象概念。实体类似于非托管的轻量级游戏对象（GameObject），它代表程序中的特定元素。此外，实体充当将各个唯一组件关联在一起的 ID，而不是包含任何代码或充当其关联组件的容器。

实体的集合存储在一个名为`World`的空间中，其中`World`的`EntityManager`负责管理该世界中的所有实体。EntityManager 包含了一些方法，您可以使用这些方法在该世界内创建、销毁和修改实体。

> NOTE
> 
> 当您创建或销毁一个实体时，这会产生结构性变化，从而影响应用程序的性能。

实体本身没有类型，但您可以根据关联的组件类型对实体进行分类。`EntityManager`负责跟踪现有实体上的组件的独特组合。这些独特的组合被称为原型（archetypes）。

# 组件

在实体组件系统（ECS）架构中，组件包含系统可读写的实体数据。

使用`IComponentData`接口（不包含任何方法）来将结构体标记为组件类型。这种组件类型只能包含非托管数据，它们可以包含方法，但最佳实践是仅作为纯数据。如果您想创建一个托管组件，则将其定义为类。

实体组件的唯一集合称为原型（archetype）。ECS 架构将组件数据按原型存储在称为块（chunks）的 16KB 内存块中。

# 系统

系统提供将组件数据从当前状态转换为下一个状态的逻辑。例如，一个系统可能会通过将所有移动实体的速度乘以上次更新以来的时间间隔来更新它们的位置。

系统在主线程上每帧运行一次。系统被组织成一个层次结构的系统组，您可以使用这些系统组来组织系统更新的顺序。

您可以在 Entities 中创建托管或非托管系统。要定义托管系统，请创建一个继承自 SystemBase 的类。要定义非托管系统，请创建一个继承自 ISystem 的结构体。

ISystem 和 SystemBase 都有三个可覆写的方法：OnUpdate、OnCreate 和 OnDestroy。系统的 OnUpdate 方法每帧执行一次。

一个系统只能处理一个世界中的实体，因此系统与特定世界关联。您可以使用 World 属性返回系统所附加到的世界。

默认情况下，一个自动引导过程会创建每个系统和系统组的实例。引导过程创建了一个具有三个系统组的默认世界：InitializationSystemGroup、SimulationSystemGroup 和 PresentationSystemGroup。默认情况下，一个系统的实例被添加到 SimulationSystemGroup。您可以使用 [UpdateInGroup] 属性来覆盖此行为。

要禁用自动引导过程，请使用脚本定义 #UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP。

# 世界

World 是一个实体的集合。实体的 ID 号在其所属的世界中是唯一的。一个世界拥有一个 EntityManager 结构体，您可以使用它在世界内创建、销毁和修改实体。

一个世界拥有一组系统，这些系统通常只访问同一世界内的实体。此外，世界中具有相同组件类型集合的实体会一起存储在一个原型（archetype）中，这决定了程序中的组件如何在内存中组织。

# 原型

原型（archetype）是一个唯一标识符，用于标识具有相同独特组件类型组合的世界中所有实体。例如，具有组件类型 A 和 B 的世界中的所有实体共享一个原型。具有组件类型 A、B 和 C 的所有实体共享另一个不同的原型，而具有组件类型 A 和 Z 的所有实体则共享又一个不同的原型。

当您向实体添加或删除组件类型时，世界的 EntityManager 会将实体移动到适当的原型。例如，如果一个实体具有组件类型 A、B 和 C，而您移除了其 B 组件，则 EntityManager 会将该实体移动到具有组件类型 A 和 C 的原型。如果不存在这样的原型，EntityManager 就会创建它。

> 注意！
>
> 频繁移动实体会消耗大量资源，并降低应用程序的性能。

基于原型的实体组织方式意味着通过组件类型查询实体是非常高效的。例如，如果您想查找具有组件类型 A 和 B 的所有实体，您可以找到具有这些组件类型的所有原型，这比逐个扫描所有实体的性能更好。一个世界中现有的原型集合往往在程序生命周期的早期就趋于稳定，因此您可以缓存查询以获得更快的性能。

![原型](./imgs/Archetype.png)

## 原型块(Chunk)

具有相同原型的所有实体和组件都存储在称为块（chunks）的统一内存块中。每个块包含 16KiB，它们可以存储的实体数量取决于块的原型中的组件数量和大小。EntityManager 根据需要创建和销毁块。

一个块包含一个用于每种组件类型的数组，以及一个额外的数组用于存储实体 ID。例如，在具有组件类型 A 和 B 的原型中，每个块都有三个数组：一个用于存储 A 组件值的数组，一个用于存储 B 组件值的数组，以及一个用于存储实体 ID 的数组。

块的数组紧凑排列：块的第一个实体存储在这些数组的索引 0 处，块的第二个实体存储在索引 1 处，后续实体依次存储在连续索引中。当向块中添加新实体时，它将存储在第一个可用索引处。当从块中移除实体（因为正在销毁或者正在移动到另一个原型）时，块的最后一个实体会被移动以填补空缺。

当向原型中添加实体时，如果原型现有的块都已满，EntityManager 则会创建一个新的块。当从块中移除最后一个实体时，EntityManager 销毁这个块。

![原型块](./imgs/Chunk.png)

# 结构性变换

导致 Unity 重新组织内存块或内存块内容的操作称为结构性更改。了解哪些操作是结构性更改非常重要，因为它们可能会占用大量资源，并且只能在主线程上执行；不能用于作业。

以下操作被视为结构性更改：

- 创建或销毁实体。
- 添加或移除组件。
- 设置共享组件值。

## 创建实体

创建一个实体时，Unity会将实体添加到现有的内存块中，如果没有可用于实体原型的内存块，则会创建一个新的内存块并将实体添加到其中。

## 销毁一个实体

销毁一个实体时，Unity会从其内存块中移除该实体。如果移除实体后内存块中出现了空隙，Unity会将内存块中的最后一个实体移动到空隙处。若移除实体后内存块为空，Unity会释放该内存块。

## 增加删除组件

当您为实体添加或移除组件时，将改变实体的原型。Unity会将每个实体存储在与实体原型匹配的内存块中。这意味着如果您更改了实体的原型，Unity必须将实体移到另一个内存块。如果不存在合适的内存块，Unity会创建一个新的内存块。如果移动后上一个内存块出现空隙或为空，Unity会分别将该内存块中的最后一个实体移动到空隙处或释放该内存块。

## 设置共享组件

当您设置实体的共享组件值时，Unity会将实体移动到与新共享组件值相匹配的内存块。如果不存在合适的内存块，Unity会创建一个新的内存块。如果移动后上一个内存块出现空隙或为空，Unity会分别将该内存块中的最后一个实体移动到空隙处或释放该内存块。

> NOTE
>
> 设置常规组件值不是结构性更改，因为它不需要Unity移动实体。

# Sync points(暂时不知道咋翻译，同步点？？)

不能直接在Job中进行结构性更改，因为这可能会使已经计划的其他Job失效，并创建一个同步点。

同步点（sync point）是程序执行过程中等待迄今为止所有已计划作业完成的点。同步点限制了您在一段时间内使用作业系统中所有可用工作线程的能力。因此，您应该尽量避免同步点。ECS中数据的结构性更改是同步点的主要原因。

结构性更改不仅需要同步点，而且还会使对任何组件数据的所有直接引用失效。这包括DynamicBuffer实例以及提供对组件直接访问的方法结果，例如ComponentSystemBase.GetComponentDataFromEntity。

## 避免Sync points

可以使用实体命令缓冲区来排队结构性更改，而不是立即执行它们。您可以在帧的稍后时间回放存储在实体命令缓冲区中的命令。这将多个分布在帧中的同步点减少到一个同步点。

每个标准ComponentSystemGroup实例都提供一个EntityCommandBufferSystem作为组中第一个和最后一个更新的系统。如果您从这些标准系统之一获取实体命令缓冲区对象，则所有结构性更改都会在帧的相同时间点发生，从而产生一个同步点。您还可以使用实体命令缓冲区在作业中记录结构性更改，而不仅仅是在主线程上进行结构性更改。

如果您不能为任务使用实体命令缓冲区，请在系统执行顺序中将执行结构性更改的任何系统分组在一起。如果连续更新两个都进行结构性更改的系统，它们只会创建一个同步点。

# 关于安全机制

Entities包提供了一个框架和一组API，以便您可以使用面向数据的设计原则来高效地转换数据。这涉及尽可能利用Burst编译器和本地互操作来直接访问数据。这种方法有时会违反C#语言内置的安全机制。

Entities包的许多内部API使用不安全的代码块和原始指针来访问数据，以获得最佳性能。有些API返回对可能比所引用数据生命周期更长的数据的引用。以下包含了有关Entities安全性的信息以及您可能遇到的一些陷阱。

## 保卫机制

在大多数情况下，Entities框架和支持包会尝试在编辑器中以及启用安全检查时防范安全问题。在这些情况下的安全错误应该抛出有效的错误，提供如何修复的信息，并防止编辑器崩溃。然而，在运行时构建中，没有任何保证这些情况不会导致崩溃或内存损坏。您还可以通过编辑器中的Safety Checks设置（Jobs > Burst > Safety Checks）禁用一些作业和安全检查。

## 结构性变换

在Entities安全性方面最常见的问题之一是结构性更改导致数据失效。这是因为结构性更改会修改实体的原型，从而将实体移动到另一个内存块。

> NOTE:
>
> 启用和禁用可启用组件不是结构性更改。然而，所有启用或禁用组件的作业必须在检查启用状态之前完成，以确保已完成对组件启用状态的所有更改。

Entities API将数据存储在内存块中，通常通过作业系统或主线程进行访问。作业系统通常处理所有用NativeContainers传入的数据的安全性，并使用标记表示数据是被读取、写入还是两者兼有。然而，任何导致结构性更改的API可能会使这些数据在内存中移动，并使对该数据的任何引用失效。

## RefRW/RefRO

Entities包含显式引用类型，您可以使用它们将所包含的类型标记为可读写（RefRW）或只读（RefRO）。这些引用类型具有检查功能，以确保在启用安全检查时运行时所包含的类型仍然有效。结构性更改可能导致所包含的类型不再有效。

# 未经监管的安全行为

> 有几种情况没有受到保护。本节概述了由于Entities API在编辑器中可能导致崩溃或内存损坏的任何情况

## IJobEntity（！！！）

IJobEntity允许您使用外部EntityQuery来调度作业。这将使用EntityQuery检索实体，然后使用这些实体执行IJobEntity的Execute方法。ECS不会检查实体是否真正具有组件参数，因此您必须确保它们保持同步。如果Execute参数与查询的组件不匹配，可能会导致崩溃或内存损坏。

## InternalCompilerInterface(？？？)

InternalCompilerInterface静态类包含了许多方法，它们将一些DOTS内部暴露给源生成的代码。这是必要的，因为生成的代码通常只能调用公共API。